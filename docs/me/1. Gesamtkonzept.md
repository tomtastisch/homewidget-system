Unten hast du ein Gesamtkonzept plus genau 10 Tickets, die du nacheinander (oder bei Bedarf parallel) an den
JetBrains-Agent/Claude geben kannst.
Jedes Ticket enthält:
• den Gesamt-Kontext,
• ein klar abgegrenztes Ziel,
• und eine Arbeitsanweisung nach deinem gewünschten Muster (Analyse → Planung → Umsetzung → Test → Iteration) inkl.
Verweis auf general-gd.md.

Du kannst die Ticket-Prompts jeweils 1:1 in der IDE verwenden.

⸻

Gesamtkonzept (Kurzfassung)

System: Proof-of-Concept für ein Home-Widget-System analog CHECK24:
• Backend
• FastAPI als API-Schicht.
• SQLModel + SQLite als ORM/DB (später Postgres möglich).
• Auth:
• E-Mail/Passwort.
• Passwort-Hashing mit Argon2id (argon2-cffi).
• OAuth2PasswordBearer + JWT (Access + Refresh Token).
• User-Rollen: demo, common, premium.
• Domain:
• User-Domäne mit Rollen/Flags.
• Widget-Domäne mit selbstbeschreibenden Widgets (id, product_key, version, type, title, description, image_url,
cta_label, cta_target, payload, visibility_rules, priority, slot, freshness_ttl, enabled).
• HomeFeed-Service: filtert/sortiert Widgets nach Rolle, Demo vs. User, nutzt Cache.
• Caching:
• fastapi-cache2 mit In-Memory-Backend, TTL gemäß freshness_ttl.
• Rate-Limiting:
• einfache In-Memory-Implementierung (pro IP/User), plus konzeptioneller Hinweis auf Nginx/API-Gateway-Limits.
• Frontend (Mobile)
• Expo React Native (TypeScript).
• Screens: Landing (Login/Registrieren/Demo), Login, Home.
• Auth-Flow:
• Login → Access + Refresh Token vom Backend.
• Tokens in expo-secure-store.
• Automatischer Refresh bei abgelaufenem Access-Token.
• Logout = Token lokal löschen.
• Home-Screen:
• ruft /home, rendert Widgets abhängig von type.
• Demo-User (kein Token) vs. eingeloggte User (Token, Rolle).
• Qualität
• Strikte Typisierung (Python/TS).
• Einhaltung deiner Richtlinien aus general-gd.md.
• Testgetriebene, iterative Vorgehensweise.
• Backend-Tests (Auth, HomeFeed, Cache, Rate-Limit), einfache RN-Tests (API-Client, Widget-Rendering).
• Dokumentation: CONCEPT.md, DEVELOPER_GUIDELINE.md, README.md.

⸻

Ticket 1 – Projekt- und Backend-Grundstruktur

TICKET 1: REPO- UND BACKEND-GRUNDSKELETT (FASTAPI + SQLMODEL)

Kontext:

- Es soll ein PoC für ein Home-Widget-System entstehen (CHECK24-ähnlich).
- Architektur ist mehrschichtig: Gateway → API → Auth/Security → Domain → Persistence → Cache/Rate-Limit → Clients (Expo
  RN).
- Dies ist Schritt 1: saubere Repo- und Backend-Grundstruktur anlegen.

Ziel:

- Erzeuge eine saubere, modulare Backend-Projektstruktur auf Basis von FastAPI + SQLModel + SQLite.
- Bereite alles so vor, dass spätere Tickets Auth, Domain-Logik, Cache, Rate-Limit und Tests konsistent ergänzen können.

Vorgaben:

- Lies und beachte konsequent die Vorgaben aus der Datei `general-gd.md` im Projektroot (Code-Stil,
  Architekturprinzipien, Clean Architecture etc.).
- Halte dich an das Vorgehen:
    1) Analyse der Anforderungen
    2) Planung der Struktur (Packages, Module, Verantwortlichkeiten)
    3) Umsetzung (minimal funktionsfähiges Skelet)
    4) Test (Health-Check-Endpoint, basic import-Tauglichkeit)
    5) Iteration, bis das Grundgerüst stabil ist.

Aufgaben:

1. Repository-Struktur anlegen:
    - `backend/`
    - innerhalb von `backend/` z.B.:
        - `app/main.py`
        - `app/core/config.py`
        - `app/core/db.py`
        - `app/api/__init__.py`
        - `app/domain/__init__.py`
        - `app/domain/users/`
        - `app/domain/widgets/`
        - `tests/` (für Backend-Tests)
2. Abhängigkeiten (nur deklarieren, noch nicht voll nutzen):
    - fastapi
    - uvicorn[standard]
    - sqlmodel
    - sqlite (oder entsprechende Treiber)
    - pydantic (kommt mit FastAPI, aber Struktur sauber aufsetzen)
3. In `app/main.py`:
    - FastAPI-Instanz erstellen.
    - Health-Endpoint `/health` implementieren, der `{ "status": "ok" }` liefert.
4. In `app/core/config.py`:
    - Konfigurationsobjekt (z.B. Settings-Klasse) mit:
        - APP_NAME
        - DB_URL (für SQLite, z.B. `sqlite:///./app.db`)
        - weitere Platzhalter, aber noch ohne Logik.
5. In `app/core/db.py`:
    - SQLModel-Engine und Session-Handling vorbereiten (aber noch ohne konkrete Modelle).
6. Basistests:
    - Ein einfacher Test, der:
        - die App testweise startet (TestClient),
        - `/health` abfragt,
        - auf Status 200 und JSON `{ "status": "ok" }` prüft.

Arbeitsweise:

- Dokumentiere in Kommentaren / kurzen Docstrings, warum du dich für bestimmte Strukturentscheidungen entscheidest.
- Achte bei allen Schritten auf Konsistenz mit `general-gd.md`.
- Falls Konflikte auftreten (z.B. typische FastAPI-Beispiele vs. deine Richtlinien), analysiere kurz im Codekommentar
  die Abwägung und triff eine begründete Entscheidung.

⸻

Ticket 2 – SQLModel-Modelle und DB-Schicht (User, Widget, RefreshToken)

TICKET 2: SQLMODEL-DATENMODELLE UND DB-SCHICHT

Kontext:

- Backend-Grundstruktur existiert bereits (siehe Ticket 1).
- Jetzt sollen die zentralen Datenmodelle für User, Widget und RefreshToken in SQLModel angelegt werden.

Ziel:

- Definiere SQLModel-Modelle für:
    - User (mit Rollen Flags demo/common/premium),
    - Widget,
    - RefreshToken (für den Refresh-Flow).
- Implementiere DB-Initialisierung (Schema-Erzeugung) und stelle sicher, dass sie testbar ist.

Vorgaben:

- Vorgaben aus `general-gd.md` beachten.
- Vorgehen: Analyse → Planung → Umsetzung → Test → Iteration.
- Typisierungen sauber und konsistent halten.

Aufgaben:

1. UserModel (SQLModel, table=True):
    - Felder:
        - id (int, PK)
        - email (str, unique, index)
        - password_hash (str)
        - role (Literal["demo", "common", "premium"])
        - created_at, updated_at (optional, aber sinnvoll)
2. WidgetModel:
    - Felder:
        - id (int, PK) oder string-id (stabile ID)
        - product_key (str)
        - version (str)
        - type (str oder Literal für bekannte Layouts)
        - title (str)
        - description (Optional[str])
        - image_url (Optional[str])
        - cta_label (Optional[str])
        - cta_target (Optional[str])
        - payload (JSON-fähige Struktur, z.B. dict[str, Any] via Field mit sauberen Typ-Hinweisen)
        - visibility_rules (Liste von Rollen oder ein Enum-Feld)
        - priority (int)
        - slot (str, z.B. "hero", "above_the_fold", ... oder Optional[str])
        - freshness_ttl (int, Sekunden)
        - enabled (bool)
3. RefreshTokenModel:
    - Felder:
        - id (int, PK)
        - user_id (FK auf User)
        - token (str, hashed oder random)
        - expires_at (datetime)
4. DB-Initialisierung:
    - In `app/core/db.py` eine Funktion, die `SQLModel.metadata.create_all(engine)` ausführt.
    - Sicherstellen, dass dies nur einmalig bzw. kontrolliert erfolgt (keine Wild-West-Initialisierung).
5. Tests:
    - Test, der:
        - eine Test-DB (SQLite in-memory oder temporäre Datei) verwendet,
        - `create_all` ausführt,
        - prüft, ob Tabellen existieren (z.B. mit einfachen Queries oder SQLModel-Mechanismen).

Arbeitsweise:

- Alle Tabellen klar benennen (table-Namen).
- Beziehungen (User ↔ RefreshToken) als Relationship oder explizit mit ForeignKey modellieren (mindestens FK-Level).
- Kommentare/Docstrings für jedes Modell, in denen du knapp erklärst, wofür es im Gesamtsystem steht.

⸻

Ticket 3 – Auth-Flow: Registrierung, Login, Argon2, JWT (Access + Refresh)

TICKET 3: AUTHENTIFIZIERUNG (REGISTER/LOGIN) MIT ARGON2 + JWT

Kontext:

- Datenmodelle für User und RefreshToken existieren.
- Jetzt soll der Auth-Flow (Register/Login) mit sicherem Passwort-Handling und JWTs implementiert werden.

Ziel:

- Implementiere:
    - `POST /auth/register`
    - `POST /auth/login`
- Nutze:
    - argon2-cffi für Passwort-Hashing (Argon2id),
    - JWT (Access + Refresh Token) mit OAuth2PasswordBearer für Access-Token.

Vorgaben:

- `general-gd.md` beachten.
- Analyse → Planung → Umsetzung → Test → Iteration.
- Access-Token kurzlebig, Refresh-Token länger gültig.
- E-Mail/Passwort als Basis, Rollen-Feld initial z.B. auf "common" oder "demo" setzen.

Aufgaben:

1. Passwort-Hashing:
    - Utility-Funktionen:
        - `hash_password(plain: str) -> str`
        - `verify_password(plain: str, hashed: str) -> bool`
    - Implementiert via `argon2-cffi` (Argon2id).
2. JWT-Utilities:
    - Funktionen:
        - `create_access_token(data: dict, expires_delta: timedelta)`
        - `create_refresh_token(data: dict, expires_delta: timedelta)`
    - Verwende `python-jose` oder `PyJWT`.
    - Konfiguration (Secret, Algo, Laufzeiten) aus `app/core/config.py`.
3. Endpunkt `POST /auth/register`:
    - Input: E-Mail, Passwort, optional Rolle (oder default).
    - Ablauf:
        - prüfen, ob E-Mail frei ist,
        - Passwort hashen,
        - User anlegen, speichern,
        - User-Daten (ohne Passwort) zurückgeben.
4. Endpunkt `POST /auth/login`:
    - Input: E-Mail, Passwort.
    - Ablauf:
        - User holen,
        - Passwort prüfen,
        - beim Erfolg:
            - Access-Token + Refresh-Token erstellen,
            - Refresh-Token in DB speichern (RefreshTokenModel),
            - Rolle des Users beilegen.
5. Tests:
    - Registrierung und Login für happy path.
    - Fehlerfälle:
        - bereits existierende Mail,
        - falsches Passwort.

Arbeitsweise:

- Achte auf saubere Fehlercodes (400, 401).
- Gib keine sensiblen Details in Fehlermeldungen preis (z.B. „User existiert nicht“ vs. „falsches Passwort“, ggf.
  neutraler).
- Baue Unit-Tests für die Hash-Utilitys und Integrationstests für die Endpunkte.

⸻

Ticket 4 – Refresh-Token-Flow (/auth/refresh) + Security-Plumbing

TICKET 4: REFRESH-TOKEN-FLOW UND SECURITY-PLUMBING

Kontext:

- Register/Login + Access/Refresh-Tokens existieren.
- Jetzt wird der `/auth/refresh`-Flow und die zentrale Security-Integration (OAuth2PasswordBearer, get_current_user)
  ergänzt.

Ziel:

- Implementiere:
    - `POST /auth/refresh` (nimmt Refresh-Token, liefert neuen Access-Token).
    - zentrale Dependency `get_current_user` (OAuth2PasswordBearer), die JWT prüft.

Vorgaben:

- `general-gd.md` beachten.
- Analyse → Planung → Umsetzung → Test → Iteration.
- Refresh-Token in DB prüfen, Ablaufzeit beachten.

Aufgaben:

1. `/auth/refresh`:
    - Input: Refresh-Token.
    - Ablauf:
        - in DB nach gültigem RefreshToken suchen (nicht abgelaufen),
        - User zuordnen,
        - neuen Access-Token generieren,
        - optional Refresh-Token rotieren (optional für PoC).
2. `get_current_user`:
    - OAuth2PasswordBearer mit Access-Token.
    - Token dekodieren, User-ID extrahieren, User aus DB holen.
    - Fehlerhandling (401 bei ungültigem/abgelaufenem Token).
3. Rollen:
    - Stelle sicher, dass `get_current_user` auch die Rolle zurückgibt (User-Objekt).
4. Tests:
    - Refresh-Flow (gültiger Refresh-Token → neuer Access-Token).
    - Abgelaufener/ungültiger Refresh-Token → 401/400.
    - `get_current_user` happy path + Fehlfälle.

Arbeitsweise:

- Sauber trennen:
    - Token-Utilitys vs. Endpoint-Logik.
    - Security-Dependencies in separatem Modul (`app/core/security.py` oder ähnlich).
- Tests schreiben, bevor du die finalen Details polierst, und dann iterativ korrigieren.

⸻

Ticket 5 – Widget-Domäne und HomeFeed-Service (/home) mit Caching

TICKET 5: WIDGET-DOMÄNE UND HOMEFEED-SERVICE MIT CACHING

Kontext:

- User-/Auth-Schicht steht.
- Datenmodelle für Widgets existieren.
- Jetzt soll die eigentliche Domain-Logik für Home-Widgets aufgebaut werden.

Ziel:

- Implementiere:
    - Widget-spezifische Services (z.B. WidgetRepository, WidgetSelectionService).
    - HomeFeed-Service, der Widgets nach Rolle (demo/common/premium) filtert, sortiert und cached.
    - Endpoint `GET /home`.

Vorgaben:

- `general-gd.md` beachten.
- Analyse → Planung → Umsetzung → Test → Iteration.
- Widgets werden in der DB gepflegt (oder initial als Seed-Daten).
- Caching über `fastapi-cache2` (In-Memory) pro User/Rolle.

Aufgaben:

1. Widget-Services:
    - Funktion(en) zum Laden aller aktiven Widgets (`enabled=True`).
    - Filtern nach:
        - `visibility_rules` (enthält Rolle),
        - ggf. Demo-Widgets (für Gast).
2. HomeFeed-Service:
    - Funktion `get_home_widgets(user_or_demo)`:
        - Wenn kein User (Gast): Demo-Widgets.
        - Wenn User: Widgets nach Rolle filtern.
        - Sortierung:
            - optional nach Slot,
            - danach nach Priority (aufsteigend).
3. Caching:
    - Integriere `fastapi-cache2`:
        - Initialisierung beim App-Start.
        - Dekorator auf der HomeFeed-Funktion oder `/home`-Handler.
        - TTL: z.B. min(freshness_ttl) oder ein fixer Wert (PoC).
4. Endpoint `GET /home`:
    - Wenn Access-Token vorhanden: `get_current_user` nutzen.
    - Wenn kein Access-Token: als Gast → Demo/HomeFeed für Demo.
    - Response: Liste von Widgets (Schema definieren).
5. Tests:
    - Gast-HomeFeed (Demo-Widgets).
    - User mit Rolle common/premium → unterschiedliche Widgets-Auswahl.
    - Cache-Verhalten (z.B. 2 Aufrufe, gleiche DB-Ergebnisse, Logging zur Prüfung).

Arbeitsweise:

- Domain-Logik klar von API-Endpunkten trennen (Services/UseCases in separaten Modulen).
- Ausführliche Docstrings zur Business-Logik des HomeFeeds.

⸻

Ticket 6 – Rate-Limiting (In-Memory) für Login/Home

TICKET 6: RATE-LIMITING UND COOLDOWN (IN-MEMORY)

Kontext:

- Auth-Endpoints und Home-Feed existieren.
- Jetzt soll eine einfache Rate-Limit-/Cooldown-Mechanik ergänzt werden.

Ziel:

- Implementiere ein simples, aber klares In-Memory-Rate-Limit für:
    - `POST /auth/login`
    - `GET /home`
- Konzeptionelle Einordnung: später Nginx/API-Gateway + Redis/ähnliches.

Vorgaben:

- `general-gd.md` beachten.
- Analyse → Planung → Umsetzung → Test → Iteration.
- Rate-Limit einfach halten, aber sauber strukturieren.

Aufgaben:

1. Design:
    - Datenstruktur (z.B. dict[Key, list[timestamps]] oder dict[Key, Counter + last_reset]).
    - Key:
        - für Login: IP + evtl. E-Mail.
        - für Home: IP oder User-ID.
2. Middleware oder Dependency:
    - Implementiere eine wiederverwendbare Rate-Limit-Komponente, die:
        - pro Aufruf prüft,
        - bei Überschreitung Fehler (429) zurückgibt.
3. Parameter:
    - z.B. Login: max 5 Versuche pro 5 Minuten.
    - Home: einfache Obergrenze (z.B. 60 Requests/Minute).
4. Tests:
    - Mehrfachaufrufe, die in das Limit laufen → 429.
    - Nach abgelaufener Zeitspanne wieder möglich.

Arbeitsweise:

- Code so strukturieren, dass ein späterer Austausch gegen Redis oder einen externen Provider einfach wäre.
- Im Code klar kommentieren: „PoC-Implementierung, in Produktion würde hier X stehen“.

⸻

Ticket 7 – Expo RN-App: Projekt-Setup, Navigation, Grund-Screens

TICKET 7: EXPO REACT NATIVE – GRUNDSETUP UND NAVIGATION

Kontext:

- Backend ist (weitgehend) funktionsfähig.
- Jetzt wird die Expo React Native App als Client aufgebaut.

Ziel:

- Erzeuge ein Expo-Project mit TypeScript.
- Implementiere grundlegende Navigation und drei Screens:
    - LandingScreen (Login/Registrieren/Demo),
    - LoginScreen,
    - HomeScreen (noch mit Mockdaten).

Vorgaben:

- `general-gd.md`-Prinzipien soweit sie auf Frontend-Code übertragen werden können (Struktur, Sauberkeit).
- Analyse → Planung → Umsetzung → Test → Iteration.

Aufgaben:

1. Expo-Projekt (TypeScript) anlegen:
    - `mobile/`-Ordner im Repo.
    - Navigation mit `@react-navigation/native` + Stack.
2. Screens:
    - LandingScreen:
        - Logo/Branding-Placeholder.
        - Buttons: „Anmelden“, „Registrieren“ (kann später stub sein), „Demo“.
    - LoginScreen:
        - Form mit E-Mail/Passwort (noch ohne Backend-Anbindung).
    - HomeScreen:
        - Platzhalter-Widgets (Mock-Array).
3. Navigation:
    - Stack: Landing → Login → Home.
    - „Demo“-Button navigiert direkt zu Home (ohne Token).
4. Erste Tests / Linting:
    - Sicherstellen, dass App startet und die Navigation funktioniert.
    - Optionale einfache Jest-Tests für einen kleinen UI-Teil.

Arbeitsweise:

- Strukturiere den Code in:
    - `screens/`, `components/`, `navigation/`, `services/` (noch leer).
- Achte auf TypeScript-Typisierung der Props/Navigationsparameter.

⸻

Ticket 8 – RN-Auth-Flow, API-Client, Secure Store, Logout

TICKET 8: RN-AUTH-FLOW MIT API-CLIENT, TOKEN-SPEICHERUNG UND LOGOUT

Kontext:

- RN-App-Grundgerüst steht.
- Backend bietet `/auth/register`, `/auth/login`, `/auth/refresh`, `/home`.

Ziel:

- Implementiere den vollständigen Auth-Flow in der RN-App:
    - Login, Token-Speicherung, Refresh, Logout.
    - Unterscheidung „Gast/Demo“ vs. „eingeloggt“.

Vorgaben:

- expo-secure-store für Access-/Refresh-Token.
- Analyse → Planung → Umsetzung → Test → Iteration.
- Abbildung des Backend-API-Vertrags.

Aufgaben:

1. API-Client:
    - Service-Klasse (z.B. `apiClient.ts`):
        - Basis-URL konfigurierbar.
        - Funktionen:
            - `login(email, password)`
            - `refreshToken(refreshToken)`
            - `getHomeWidgets(accessToken?)`
2. Token-Handling:
    - AuthContext oder ähnlicher globaler State:
        - `accessToken`, `refreshToken`, `userRole`.
    - On Login:
        - API call → Tokens + Role.
        - Tokens in SecureStore speichern.
    - On App-Start:
        - Tokens aus SecureStore laden.
        - Falls gültig, als „eingeloggt“ behandeln.
3. Refresh-Flow:
    - Wenn `/home`-Call 401 (Access expired):
        - `refreshToken` aufrufen.
        - bei Erfolg: neuen AccessToken speichern und Request wiederholen.
4. Logout:
    - Tokens aus SecureStore entfernen.
    - Auth-State zurücksetzen.
    - Navigation zurück zur Landing.

Arbeitsweise:

- Fehlerzustände klar behandeln (falsche Login-Daten, Netzwerkfehler).
- Typen für Responses (TS-Interfaces) parallel zu Pydantic-Schemas im Backend halten.
- Optionale kleine Tests für API-Client (z.B. mit Mocks).

⸻

Ticket 9 – RN-HomeScreen: Rendering der Widgets nach Typ + Demo vs. User

TICKET 9: RN-HOMESCREEN – WIDGET-RENDERING NACH TYP UND ROLLE

Kontext:

- Auth-Flow funktioniert.
- Backend liefert Widgets über `/home`.

Ziel:

- HomeScreen ruft `/home` auf und rendert die Widgets:
    - verschiedene Layouts je nach `type` (z.B. card/banner).
    - Unterschied Demo vs. eingeloggter User sichtbar machen.

Vorgaben:

- Analyse → Planung → Umsetzung → Test → Iteration.
- UI muss nicht „pixel-perfect“ sein, aber klar zeigen:
    - Personalisierte Inhalte vs. Demo-Inhalte.
- Typen (TS) müssen mit Backend-Widget-Schema kompatibel sein.

Aufgaben:

1. Widget-Typen in TS:
    - Interface `Widget` mit denselben Feldern wie Backend-Schema (id, product_key, type, title, description, image_url,
      cta_label, ...).
2. HomeScreen-Logik:
    - Bei Mount:
        - Zugriff auf Auth-State.
        - `getHomeWidgets(accessToken)` aufrufen.
    - Loading-/Error-State anzeigen.
3. Rendering:
    - Je `widget.type` unterschiedliche Komponente wählen:
        - `WidgetCard`
        - `WidgetBanner`
        - etc., minimalistisch gehalten.
    - CTA-Klick (Button) löst vorerst nur ein `console.log` oder `Alert` aus.
4. Demo vs. User:
    - Demo (ohne Token) → Widgets, die entsprechend Demo-Markierung/fixen Demo-Set kommen.
    - User → personalisierte Widgets (z.B. andere Titel/CTA).
5. Tests:
    - Snapshot-/Rendering-Test für `WidgetCard`/`WidgetBanner`.
    - Minimaler Test für HomeScreen, dass Widgets aus einer Mock-API gerendert werden.

Arbeitsweise:

- UI-Komponenten klar strukturieren, damit später weitere Widget-Typen leicht ergänzt werden können.
- In Kommentaren kurz erklären, wie man neue Widget-Typen nachrüstet.

⸻

Ticket 10 – Tests, CONCEPT.md, DEVELOPER_GUIDELINE.md, README

TICKET 10: TEST-ABRUNDUNG UND DOKUMENTATION (CONCEPT, GUIDELINE, README)

Kontext:

- Backend + RN-App sind weitgehend implementiert.
- Jetzt soll das Ganze test- und dokumentationsseitig „runde Kanten“ bekommen.

Ziel:

- Backend-Tests ergänzen und konsolidieren.
- Grundstruktur für Dokumentation erstellen:
    - CONCEPT.md
    - DEVELOPER_GUIDELINE.md
    - README.md

Vorgaben:

- `general-gd.md` beachten.
- Analyse → Planung → Umsetzung → Test → Iteration.
- Fokus: Nachvollziehbarkeit des Gesamtsystems für Außenstehende.

Aufgaben:

1. Tests Backend:
    - Tests für:
        - `/auth/register`, `/auth/login`, `/auth/refresh`
        - `/home` (Demo und verschiedene Rollen)
        - Rate-Limit (Login/Home, z.B. 429-Fall)
        - Caching (z.B. indirekt über Logging oder Call-Zählung testbar)
2. Tests RN:
    - Mindestens:
        - Widget-Rendering-Test,
        - API-Client-Unit-Test mit Mock.
3. CONCEPT.md:
    - Kurzbeschreibung des Problems.
    - Gesamtarchitektur (Schichten, Komponenten).
    - Auth-/Security-Konzept (Argon2, JWT, Refresh).
    - Caching/Rate-Limit.
    - Deployment-Idee (Nginx/TLS, PoC vs. Produktion).
4. DEVELOPER_GUIDELINE.md:
    - Aus Sicht eines Produkt-Teams:
        - Wie wird ein neues Widget als Produkt integriert?
        - Welche Felder müssen gesetzt werden?
        - Wie wird getestet?
5. README.md:
    - Projektübersicht.
    - Setup-Anleitung (Backend + Mobile).
    - Verweis auf CONCEPT/GUIDELINE.
    - kurze Hinweise zur Demo-Nutzung (Login/Gast-Flows).

Arbeitsweise:

- Achte bei Doku auf Klarheit und knappe, aber vollständige Beschreibungen.
- Tests so schreiben, dass sie das beabsichtigte Verhalten dokumentieren und regressionssicher machen.

⸻

Damit hast du:
• ein klares Gesamtkonzept,
• genau 10 Tickets,
• jedes Ticket mit Kontext, Ziel, Aufgaben und deiner gewünschten Arbeitsweise (Analyse → Planung → Umsetzung → Test →
Iteration + general-gd.md).

Du kannst sie der Reihe nach in deinem JetBrains-Agent nutzen und bekommst so ein schrittweise aufgebautes, konsistentes
System.